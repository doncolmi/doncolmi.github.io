---
layout: post
title: Node.js(10) - Socket.io
date: 2020-03-07 13:51:00 +0000
description: hello
img: ./nodejs/node.png
tags: [nodejs]
---

### 클라이언트 / 서버 통신

---

먼저 **클라이언트**란, 서버에게 서비스를 요구하는 사용자나 컴퓨터이다. **서버**란 서버프로그램이 실행되고 있는 하드웨어이다.

즉 클라이언트(**서비스 요구 사용자 또는 컴퓨터)**의 요청에 의해 서비스를 수행하고 네트워크를 관리, 제어, 감시하며 파일의 프로그램, 혹은 하드웨어 자원을 공유할 수 있는 서비스를 하는게 서버이다.

**클라이언트/서버 통신**은 서버에 있는 풍부한 자원들과 서비스를 통합된 방식으로 제공받기 위한 통신이다.

클라이언트는 서비스를 요청, 서버는 그 요청에 응답하는 형태를 가지는 네트워크 모델(혹은 그 방식을 가리켜서)을 **클라이언트/서버** 모델 이라고 한다.

<center><img src="/assets/img/nodejs/2020-03-07-Node.js-공부(10)/1.png"></center>
<center><small>클라이언트엔 PC말고도 스마트폰, 노트북도 포함된다.</small></center>

하나의 서버가 다수의 클라이언트에 서비스를 제공하는 이 모델을 **인터넷 응용 환경에서 가장 보편화된 연결 설정 방식**이다.

일반적으로 네트워크 서비스를 받기 위해 클라이언트가 통신을 시작한다. 클라이언트가 **서버에 접속을 시도**하고 그 연결 결과를 기다리거나, 서비스를 요구하고 응답을 기다린다.

**클라이언트의 이와 같은 요구에 대하여 서버가 응답을 보내는 방식으로 동작이 이루어진다.**

### 통신 프로토콜

---

통신 프로토콜이란 **통신 서비스나 기능 수행을 위해 관련 통신 당사자간 교환하는 정보의 종류 표현 형식, 교환 절차, 교환 과정**에서 실행해야 할 행위에 관한 규약이다.

대표적으론 IBM의 폐쇠형 망 구조인 SNA와 **개방형 망 구조인 TCP/IP**가 있다. TCP/IP의 응용 계층에서 적용 확장된 프로토콜로는 전자 우편 서비스의 SMTP, 파일 전송을 위한 **FTP,** 망 관리 서비스를 위한 SNMP, 그리고 우리가 주로 다루게 될 웹 서비스를 위한 **HTTP** 등이 있다.

일반적으로 서버 프로세스는 클라이언트 보다 먼저 실행되어 대기 상태에 있기 때문에, 클라이언트의 연결 요청에 항상 응답할 준비가 되어있다.

### 클라이언트/서버 통신 방식

---

**Polling 방식**은 클라이언트가 서버에 **주기적으로 요청 후 응답을 받는 방식**이다. 가장 기본적인 기법이다. 구현이 간단하지만 쓸모없는 요청과 응답 때문에 많은 트래픽이 낭비되는게 단점이다. 다음 폴링이 이루어지기 전까지 **어떤 이벤트가 왔는지 모르기에 실시간성이 보장되지 않는다**.

요청 주기를 조절할 수 있어 짧게 줄일 수 있지만, 요청 주기가 짧으면 서버에 부하를 줄 수 있어 주의해야한다. 실시간 메세지 전달이 크게 중요치 않은 서비스에 적합한 방식이다.

<center><img src="/assets/img/nodejs/2020-03-07-Node.js-공부(10)/2.png"></center>

**Long Poll 방식**은 Polling 방식의 단점인 **반복적인 요청으로 응답을 받는 형태**에서, Client가 서버에 대한 요청을 유지하여 **반복적 요청을 없애고 유효한 이벤트가 발생하면 응답해주는 형식이다.** 즉 Long 이라는 이름과 같이 오래 접속을 유지하는 것이다.

단, 무한정 기다리는게 아닌 일정 시간이 지나면 접속을 완료하고 새로 요청한다.

### WebSocket(웹소켓) 방식

---

웹소켓 방식은 위의 불편점들을 개선하기 위해 만들어진 HTML5 표준 기술이다. 클라이언트와 서버가 연결이 된 후부터 HTTP 요청/응답과는 상관없이 서버와 양방향 통신이 가능하다.

현재 API는 W3C에서 권장하고 있으며 프로토콜은 IETF에서 관리하고 있다. 웹소켓은 별도의 포트를 사용하지 않고 HTTP와 같은 80번 포트를 사용한다. 이 때문에 클라이언트인 웹 브라우저뿐만 아니라 웹 서버도 기능을 지원해야만 한다.

### Socket.io

---

그러나 웹소켓은 html5의 기술이기에 오래된 버전의 웹 브라우저에선 지원하지 않는다. 특히 익스플로러 구버전 사용자들은 웹소켓으로 작성된 웹페이지를 볼 수 없다.

**하지만 그 문제점을 해결하기 위해 나온 기술 중 하나가 Socket.io**이다. 웹 페이지가 열리는 브라우저가 웹소켓을 지원하면 웹소켓 방식으로 동작하고, 지원하지 않으면 일반 http를 이용해 실시간 통신을 흉내내는 것이다.

Socket.io는 node.js 기반으로 만들어진 기술로, 거의 모든 웹 브라우저와 모바일 장치를 지원하는 실시간 웹 어플리케이션 지원 라이브러리이다.

이것은 100% **자바스크립트**로 구현되어 있으며, 현존하는 대부분의 실시간 웹 기술들을 추상화해 놓았다. 다시 말해, Socket.io는 **자바스크립트를 이용하여 브라우저 종류에 상관없이 실시간 웹 구현이 가능하도록 한 기술이다.**

<center><img src="/assets/img/nodejs/2020-03-07-Node.js-공부(10)/3.png"></center>

Socket.io는 웹 브라우저와 웹 서버의 종류와 버전을 파악하여 가장 적합한 기술을 선택하여 사용한다.

만약 브라우저에 **FlashSocket**이라는 기술을 지원하는 플러그인이 설치되어 있다면 그것을 사용하고, **플러그인이 없으면 Ajax long Polling** 방식을 사용한다.

### 왜 사용하는데?

---

초창기에 웹은 단순히 인터넷 접속한 사용자에게 콘텐츠를 전달하는 역할이었다.

서로 상호작용은 중요치 않고, 정보 검색 및 열람 수준에 그쳤다. 하지만, 웹을 통해 서로 정보를 교환하고 스스로 커뮤니티를 만들어 교류하는 수요가 늘어 서버와 클라이언트 간 상호작용 하는 부분이 생겨났다.

Ajax와 같은 기술이 나타나면서 사용자와 긴밀히 상호작용하는 웹 서비스가 등장해 인기를 끌었다. 이러한 RIA(Rich Internet Application) 기술의 발달이 웹 소켓의 등장 배경이라 할 수 있다.

사용 방법은 **Ajax와 비슷하나 개념 면에서 Ajax와 차이를 둔다.** Ajax의 경우 웹 브라우저에서 데이터를 호출하면 웹 서버에서 호출된 값을 검색, 작성하여 웹 브라우저로 메세지를 보내는 형식의 구조라면 웹 소켓의 경우 웹 브라우저에서 호출해서 데이터를 가져가는 기능 포함 반대로 서버에서 클라이언트를 호출할 수 있는 기능까지 있다.

HTML5 웹소켓은 매우 유용한 기술이지만, 브라우저별로 지원하는 웹소켓 버전이 다르며 오래된 브라우저의 경우 지원하지 않는다. 따라서 자바스크립트를 이용하여 브라우저에 상관없이 실시간 웹을 구현할 수 있는 Socket.io를 좀 더 많이 사용한다.

### 설치

---

Socket.io도 웹소켓과 마찬가지로 브라우저에서 자바스크립트를 이용한다.

이전 장에서 다룬 **npm install 명령어로 간단히 설치 가능하다.**

`npm install socket.io`
