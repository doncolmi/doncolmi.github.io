---
layout: post
title: 02/27 Node.js 공부(구름study)
date: 2020-02-27 12:23:00 +0300
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: nodejs.jpg # Add image post (optional)
tags: [TIL, nodejs] # add tag
---

### 컨스트럭터(생성자)

---

객체를 생성하는 방법과 이와 관련된 컨스트럭터 속성에 대해 설명한다.

- 생성자 함수(Constructor Function)

    자바스크립트에서 객체를 생성하는 방법 중 하나로 생성자는 객체를 생성할 때 최초로 호출되는 함수를 의미한다.

        function SoccerPlayer() {
        	this.position = "Forward";
        }
        var VanPersie = new SoccerPlayer();
        VanPersie.position;
        // "Forward"

    생성자 함수를 이용해 객체를 생성하는 방법의 장점은 새로운 객체를 만들 때에 초기값을 전달하여 생성할 수 있다는 점이다.

    아래의 코드를 살펴보자

        function SoccerPlayer(name, position) {
        	this.name = name;
        	this.position = position;
        	this.whatIsYourName = function() {
        		return "My name is " + this.name;
        	};
        	this.whatIsYourPosition = function() {
        		return "My position is " + this.position;
        	};
        }

    위 코드는 매개변수로 name과 position을 받는다. 매개변수를 입력받으면 그를 자신의 속성값으로 취할 수 있게 했다. 그리고 이름과 포지션을 확인할 수 있는 메소드를 추가했다.

- instanceof 연산자

    instanceof 연산자를 사용한다면 특정 객체가 어떤 생성자를 이용하여 만들었는지 알 수 있다.

- 컨스트럭터 속성(constructor Property)

    우리가 새로운 객체를 생성하면 보이지 않지만 constructor이라는 속성이 생긴다. 이것은 객체를 만드는데 어떤 객체를 참조하였는지에 대한 정보를 가지고 있다.

- 내장형 객체(Built-In Object)

    내장형 객체는 앞서 설명한 자료형을 포함해 다음과 같은 것들이 있으나, 자세히 다루지 않았다.

    Object, Number, Array, String, Bollean, Function 등

### 스코프와 호이스팅

---

JS에서 스코프와 클로저는 중요한 개념이다. 하지만 스코프와 클로저가 연결된 개념이다 보니, 헷갈리거나 어려워 하는 사람이 많다. 또한 클로저는 약간 까다로운 개념이기도 하다.

### 유효 범위(Scope)란?

---

scope의 사전적인 의미는 **범위**이다. JS에서 스코프란 **작성된 코드를 둘러싼 환경**으로, 어떤 변수들에 접근할 수 있는지를 정의한다.

- 전역스코프
    - 함수 안에 포함되지 않은 곳에서 정의하는 것이다. 코드 어디에서든지 참조가능 하다.
- 지역스코프
    - 함수 내에 정의된 것으로 정의된 함수 내에서만 참조할 수 있다.

위의 설명은 다른 프로그래밍 언어에도 있는 개념이다. 하지만 **자바스크립트의 스코프는 다른 언어들과 다른 특징을 가지고 있다.** 바로 **Function-level scope**(함수 레벨 스코프)이다.

대부분의 언어들은 Block-level scope를 사용함으로써, 변수 선언이 코드 블록 단위로 유효한다. 하지만 Function-level-scope 인 JS는 함수 블록 내에서 선언된 변수는 함수 블록 내에서만 유효하고 함수 외부에서는 참조할 수 없다.

그러나 자바스크립트는 함수 레벨 스코프 이기에 하나의 함수 안에서 사용한 함수를 그 함수 밖에서도 사용할 수 있다.

**그런데 나는 위 내용은 의미가 없다고 생각한다.** ES6부터 const와 let을 사용하여 블록 레벨 스코프를 지원하기 시작했고, var를 완전히 대체했다.

### 호이스팅(hoisting)

---

사전적 의미로는 끌어 올리라고 한다. JS의 특징 중 하나이다. 함수 안에서 어떤 변수를 선언할 떄에 어떤 위치에 있던 함수의 시작위치로 끌어올리는 현상이다.

**중요한 점은 선언 부분만 위로 끌어올리고 값을 대입하는 부분은 위치 그대로 남아있다는 사실이다.**

아래 코드를 살펴보자

    function a() {
    	console.log(v);
    	var v = 100;
    	console.log(v);
    }
    
    a();

만약 자바라고 생각해보자 v는 2번 라인에서 첫 번째 `console.log(v)` 에서 v는 선언이 되지 않았기 때문에 **NullPointerException**이 떠야 정상이다. 하지만 JS는 var v가 아래에 있음을 알고 이를 끌어올린다.

여기서 중요한 점은 **선언 부분**만 위로 끌어올린거다. `var v = 100;`을 올린게 아니고 `var v;` 만 끌어 올린게 되는 거다.

 그러므로 첫 번째 console.log(v)에서는 undefined가 뜨는거다. 값이 대입 되지 않았기 때문에!

이런 호이스팅들은 함수에도 적용될 뿐더러 **코드가 혼란스러워질 가능성이 높다.** 그러므로 함수를 호출하기 전에 **최상단에 선언하는 습관**을 들여야 한다.

### 클로저

---

자바스크립트는 **클로저**라는 개념을 가지고 있다.

위의 스코프 체인과 연관되어 있으므로 위 스코프 체인에 대한 개념을 잘 이해하고 있어야 클로저 또한 이해하기 쉬워진다.

일반적으로 외부함수의 실행이 끝나면 외부 함수가 소멸되어 내부 함수가 외부 함수의 변수에 접근 할 수 없다.

하지만 **"외부 함수의 실행이 끝나고 외부 함수가 소멸된 이후에도 내부 함수가 외부 함수의 변수에 접근할 수 있는 구조"** 를 클로저 라고한다.

자신의 고유 스코프를 가진 상태로 소멸하지 않고 외부 함수에 의해 호출되는 함수를 만드는게 바로 클로저이다.

클로저는 한번에 이해하기 어려운 개념이다. 게다가 사실 이 개념에 대해 확실히 이해하고 넘어가지 않아도 이후 내용을 학습하는데 문제가 되진 않는다.

그럼에도 불구하고 소개하는 이유는 클로저가 자바스크립트가 가진 하나의 큰 특징이자, Node.js가 높은 효율성을 가지게 해주는 근간이기 때문이다.