---
layout: post
title: (DB) Index 란? - What is Index
date: 2020-09-12 17:54:00 +0000
description: hello
img: ./wit/2020-09-12-What-is-Index/1.png
tags: [What_is_this]
---

# [DB] Index란?

### 왜 이 글을 쓰는가?

---

최근 취업 준비에 바빴다. 물론 핑계일 뿐이지만, 면접을 보게 되면서 아직 나는 취업할 준비가 되있는 것인가에 대해 긴 시간을 통해 고민했다. 하지만 지금 내가 할 수 있는건 최대한 남는 시간을 쥐어짜 해당 지식들을 알아가는것 뿐이다.

그리고 최근에 본 면접 중 대답하지 못하거나 내가 전혀 무지하다고 생각해왔던 것들을 정리할 예정이다. 그중 DB에서 자주쓰는 Index에 대하여 제대로 숙지하고 있지 못한다고 생각했다. 내가 사용하는 기술인데 제대로 모른다는 것은 상당히 부끄러운 일이라고 생각한다.

그래서 오늘 이 글을 쓰게되었다.

### Index란?

---

우리가 DB에서 가장 많이 사용하는 명령어는 뭘까? 아마 SELECT(조회), INSERT(생성) 일 것이다. UPDATE(갱신), DELETE(갱신) 또한 많이 쓰지만 그것들은 INSERT가 되어야만 가능한 동작이니...

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/0.png"></center>
<center><small>select나 명령어에 대한건 구글이라는 친구에게 물어보도록 하자!</small></center>

그 중에서 우리는 SELECT를 사용하면서 검색 조건에 사용할 열들에 대해 당연하게도 INDEX를 추가해서 사용했다. 나 또한 학교 강의에서 INDEX를 추가하면 SELECT에 대한 성능이 좋아진다고 들었다. 그렇다고 모든 열들에 INDEX를 걸면 또 안된다고 배웠는데...

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/1.png"></center>
<center><small>왜 그런지 그때 궁금해 할껄 그랬따!</small></center>

일단 정리하자면 index란 말 자체가 '색인'이라는 뜻이다. 나는 읽을 책을 고를 때 전체적인 내용이 무엇인지 파악하기 위해 목차를 먼저 읽는다. 여기서 이 목차가 바로 index라고 볼 수 있다.

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/2.png"></center>
<center><small>바로 이런거?</small></center>

DB 분야에서의 Index도 비슷하게 테이블에 대한 동작 속도를 높여주는 자료 구조를 일컫는다. 고속의 검색 동작뿐 아니라 레코드의 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공하게 된다.

인덱스를 저장하는 데 필요한 디스크 공간은 보통의 테이블을 저장하는데 필요한 디스크 공간 보다 작다. 보통의 인덱스는 키-필드로 이루어져있고, 테이블의 다른 세부 항목들을 가지고 있지 않기 때문이다. RDBMS에서 인덱스란 테이블 부분에 대한 하나의 사본이라고 생각하면 된다.

### 그래서 index는 어떤 구조를 가지는가?

---

RDBMS의 인덱싱 알고리즘은 보통 `B-Tree`구조를 띄고있다. 여기서 B란 "Balanced"를 의미한다.

**B-Tree?**

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/3.png"></center>
<center><small>이미지 출처는 아래에 남기겠다.</small></center>

DB와 파일 시스템에서 자주 사용하는 구조로 이진 트리가 자식 노드가 최대 2개인 노드를 말한다면 `B-Tree`는 **자식 노드의 개수가 2개 이상인 트리를 말한다. 또한 노드 내의 데이터가 1개 이상일 수 있다.** 여기서 노드 내의 최대 데이터 수에 따라 차수를 나누는데 최대 데이터 수가 2개면 `2차 B-Tree` 라고 부르고 만약 4개라면 `4차 B-Tree` 라고 한다.

물론 여기서 차수가 홀수인지 짝수인지에 따라 알고리즘이 많이 달라진다고도 한다.

- `B-Tree`의 성립 조건
  - 하나의 노드에 데이터 수가 n개가 들어있다면 그 노드의 자식들은 n+ 1개가 되어야 한다.
  - 노드 안의 데이터들은 항상 정렬되어 있어야 한다.
  - 자식 노드들은 부모 노드 데이터를 기준으로 해당 데이터보다 작은 값들은 왼쪽 서브트리, 큰 값들은 오른쪽 서브트리에 이루어 져야 한다.
  - `Root`는 2개 이상의 자식을 가져야 한다.
  - `Root` 노드를 제외한 모든 노드는 적어도 M(차수) / 2 개의 데이터를 가져야 한다.
  - 입력된 자료들에 중복은 있을 수 없다.

`B-Tree`는 이진 트리와 마찬가지로 작은 값을 왼쪽에 큰 값을 오른쪽 서브 트리에 둔다. 탐색시 `root`부터 시작해 하향식으로 탐색해 나간다.

[이 외에 삽입, 삭제 부분과 더 자세한 정보는 해당 블로그에 있다. 위의 대략적인 설명 또한 해당블로그를 참조했다.](https://hyungjoon6876.github.io/jlog/2018/07/20/btree.html)

또한 `B-Tree`의 Index는 아래 세가지로 나뉜다.

- root block
- branch block
- leaf block
  - leaf block에는 index의 데이터와 rowid 정보가 존재한다.
  - 인덱스 별로 이러한 `B-Tree`구조를 가지고 있기 때문에, insert, update, delete 쿼리 실행시에 B-Tree에서는 삽입, 삭제 과정시에 index data를 직접 삭제하지 않고 사용하지 않는 다는 표시를 하게 된다.

해당 구조의 구조로는 여러개의 인덱스를 만들 수 있다.

만약 큰 값을 자주 조회하는 DB에선 내림차순으로 인덱스를 생성할 수도 있으며 인덱스를 두개 이상 생성시 결합 인덱스를 구성할 수도 있다. 중복된 데이터가 들어가야 할때도 있고 함수 기반의 인덱스가 있을 수도 있다.

### 그래서 인덱스를 걸면 왜 빨라지는데요?

---

우리가 사용할 DB에 10만건의 데이터가 있다고 해보자. 이들은 전혀 정리되어 있지 않아 내가 원하는 데이터를 찾을때 10만건의 데이터를 모두 조회해야 한다고 생각해보자.

벌써부터 머리가 아파온다. 매번 데이터를 조회할 때마다 10만번씩 조회를 해야 한다니...(물론 최악의 경우이지만)

하지만 10만건의 데이터가 정렬 되어있다고 생각하면 이야기가 달라진다. 인덱스는 DB를 트리 구조로 저장했기에 이진 탐색이 가능해진다.(`B-tree`가 이진 트리와 마찬가지로 값을 정렬하기 때문이다.) 여기서 선형 탐색과 이진 탐색을 설명하는건 너무 글의 내용에서 벗어난다.

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/4.png"></center>

여기서 x축은 데이터의 개수이다. 데이터가 많아지면 많아질수록 선형 탐색은 탐색 시간이 증가한다.(빅오 표기법으로 O(n)으로 나타낼 수 있다.) 그에 반해 이진 탐색은 O(log(n))으로 데이터가 많아져도 선형 탐색보다 우월한 성능을 가지는 것을 알 수있다.

물론 정렬된 상태에선 탐색이 빠르지만 장점만이 있는것이 아니다.

### 인덱스의 단점?

---

정렬되어있지 않은 데이터는 삽입 시에는 그냥 맨 뒤에 데이터를 떡하니 붙여놓으면 끝이다. 하지만 정렬되어 있는 상태라면? 이 데이터가 들어가야할 위치를 찾고 해당 위치 뒤에 있는 모든 데이터를 밀어 빈 공간을 만든다음 그 사이에 데이터를 넣어야 한다.

- 인덱스를 추가 한다면 SELECT의 속도가 빨라질 수 있지만, **INSERT 의 속도가 눈에 띄게 느려질 수있다.**
- 또한 인덱스 또한 공간을 차지하기 때문에 DB의 공간에 추가적인 공간이 필요할 수 있다.
  - 보통 DB의 10% 내외의 공간이 추가로 필요하다고 한다.
- 데이터 변경 작업이 자주 일어날 경우 인덱스를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다. ⇒ DML 속도 저하

또한 기존의 테이블에서 데이터가 DELETE 될 경우 그 공간이 지워지고 다른 데이터를 해당 공간에 쓸 수 있지만, **INDEX에서 데이터가 DELETE 될 경우엔 데이터가 지워지지 않고 사용되지 않는다는 표시만 해둔다.**(해당 내용은 위에도 적어놓았다.)

- DELETE시에 데이터가 지워지지 않고, 사용 안됨 표시가 되있다.
  - 테이블에 데이터는 10만건이 있지만, 인덱스에는 지워진 데이터들이 남아 20만건, 30만건, 그 이상이 있을 수 있다는 사실이다.
  - 이런 경우 인덱스를 사용한다 해도 좋은 수행 속도를 기대하기 힘들어진다.

### 그래서 언제 인덱스를 써야 합니까?

---

- 주로 WHERE 절에 자주 사용되는 컬럼을 인덱스로 만든다.
- 데이터의 중복도가 높은 열들에는 인덱스를 생성해도 눈에 띄는 성능 향상이 없다.
  - 예를 들자면 남자, 여자라는 데이터만 들어가는 성별 컬럼이라던가.
- 외래키가 사용되는 열엔 인덱스를 되도록 생성해주도록 하자.
- JOIN이 자주 사용되는 열에도 인덱스를 생성해주도록 하자.
- 항상 생성할 때에는 INSERT/UPDATE/DELETE가 자주 일어나는지 생각하라.
- 사용하지 않는 인덱스는 꼭!!! 제거하자!!!

### 인덱스 아키텍처

---

- **클러스터형 인덱스**

  클러스터형 인덱스는 해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. 데이터 행 자체는 한 가지의 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 **하나만 있을 수 있습니다.**

  테이블의 데이터 행이 정렬된 순서로 저장될 때만 클러스터형 인덱스가 포함된다.테이블에 클러스터형 인덱스가 없다면 해당 데이터 행은 힙이라는 정렬되지 않는 구조로 저장이 된다.

- **비 클러스터형 인덱스**

  비클러스터형 인덱스의 구조는 데이터 행으로부터 독립적입니다. 비클러스터형 인덱스는 비클러스터형 인덱스 키값이 있고 키 값 항목엔 해당 키값이 포함된 **데이터 형에 대한 포인터**가 있다.

[더 자세한 내용은 해당 페이지를 참고하자.](https://docs.microsoft.com/ko-kr/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver15)

# 마무리

---

Index에 대해서 자세히는 아니더라도 설명은 할 수 있을 정도로 공부를 해야겠다고 생각했다. 실제로 글을 정리하면서 여자친구에게도 설명(같은 전공입니다...절대 TMI가...맞았나?)해주었고, 언제 INDEX를 쓰고 쓰지 말아야 할지를 알게되었다.

최근 내가 CS가 많이 부족하다고 생각해서 이쪽으로 계속 공부해보려고 한다. 프로그래밍을 하면서 결과물은 항상 기본을 응용해서 만들어낸다 생각한다.

처음에 내가 자바를 배우면서 "for문을 어따 가져다 쓰는거야? 이런걸로 뭘 만들 수 있는거지?" 라고 생각했을 때 처럼 말이다.

푸념거리도 많지만 공부해야할 것이 더 많다. 잘 쓴 글도 아니고 그저 내가 공부하고자 해서 올린 글이니 부족한 부분이 있더라도 만약 누군가 본다면 양해해주길 바란다.

<center><img src="/assets/img/wit/2020-09-12-What-is-Index/5.png"></center>

### 출처

---

[https://hyungjoon6876.github.io/jlog/2018/07/18/rdb-indexing.html](https://hyungjoon6876.github.io/jlog/2018/07/18/rdb-indexing.html)

[https://lalwr.blogspot.com/2016/02/db-index.html](https://lalwr.blogspot.com/2016/02/db-index.html)

[https://hyungjoon6876.github.io/jlog/2018/07/20/btree.html](https://hyungjoon6876.github.io/jlog/2018/07/20/btree.html)

[https://ko.wikipedia.org/wiki/인덱스\_(데이터베이스)](<https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%8D%B1%EC%8A%A4_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)>)

_~~사실 내가 쓴 글보다 잘 정리된 위 글들을 참고하면 더 좋다.~~_

중간에 사진 출처

[https://datageek.blog/en/2018/06/05/rdbms-basics-indexes-and-clustered-indexes/](https://datageek.blog/en/2018/06/05/rdbms-basics-indexes-and-clustered-indexes/)
